//
// Created by Glin on 2023/3/29.
//
/************************************************************************************
 * 设定用数组 a 存储超高精度整数， 可将 a 表示为: an－1 an－2 … a2 a1 a0， n 为数组 a 实际存储的元素
 * 个数， 即实际存储的数组长度。怎样限定数组元素的大小，才能合理有效进行后续的运算，是超高精度编
 * 程时空优劣的关键。本文以 C 语言程序设计为例，数组元素 a［k］设为长整型(long int) ，即 a［k］可存储
 * 的最大整数大于10^6，并限定a［k］存放 3 位长整数，即 a［k］ ≥0 ＆＆ a［k］ ＜ 1000。这样使用数组，既可以
 * 保证 a［k］自身的算术运算不会溢出，又可以最优化地使用内存资源，使程序无论在时间复杂度，还是空间复杂度，
 * 都达到最优化。
 * ——大数的阶乘与自然对数的超高精度求解，马旭
 * ************************************************************************************/
/* 输入整数n，精确输出n!
 * 数组a[]用于存放最终结果，数组元素a[k]用于存储3位整数，m为数组a[]实际存储位数 */
#include "stdio.h"

#define N 100 /* N可以依据Stirling公式预先估值 */


/* 输出函数。p1, p2, p3分别为a[j]的百位数、十位数、个位数 */
void output(int m, long a[N]){
    int k;
    int p1, p2, p3;

    for(k=m-1; k>=0; k--){
        /* 需要这三个参数是因为中间的数比如042必须挨个显示，不能省0 */
        p1 = a[k] / 100;
        p3 = a[k] % 10;
        p2 = a[k] / 10 % 10;

        if(k == m-1){
            if(p1 >= 1){
                printf("%d%d%d", p1, p2, p3);
            }
            else if(p2 >= 1){
                printf("%d%d", p2, p3);
            }
            else{
                printf("%d", p3);
            }
        }else{
            printf("%d%d%d", p1, p2, p3);
        }
    }
}

int main(){
    /* n用来保存输入的数 */
    int n;
    /* c保存进位值 */
    int c;
    /* a[]存储结果 */
    long a[N] = {0};
    /* m 表示数组元素数*/
    int m = 1;

    scanf("%d", &n);
    a[0] = n;

    /* d是普通整数，a数组存储超高精度整数，下面循环重复进行a[k]与普通整数的乘法运算 */
    for(int d=n-1; d>=1; d--){
        c = 0;
        for(int k=0; k<m; k++){
            a[k] = a[k]*d + c;
            if(a[m-1] > 999)
                m++;
            c = a[k] / 1000;
            a[k] %= 1000;
        }
    }

    output(m, a);

    return 0;
}
